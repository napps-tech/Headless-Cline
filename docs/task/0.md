# VSCode依存関係排除 プロトタイプ計画

## 目的

既存のコードをプラットフォーム抽象化レイヤーを導入することで、Headless環境での実行を可能にする最小限のプロトタイプを作成します。

### アプローチ
1. **プラットフォーム抽象化レイヤーの作成**
   - `src/core/platform/`に抽象化レイヤーを作成

2. **インターフェース実装**
   - VSCode実装とHeadless実装を作成
   - 既存コードはインターフェースを通して操作
   - 必要最小限の機能のみ実装

3. **段階的な移行**
   - 1機能ずつインターフェースを作成
   - 動作確認を行いながら進める

4. **テストと検証**
   - 各インターフェース実装後に動作確認
   - エラーが発生した場合は即座に修正
   - 全ての依存関係が解決されるまで繰り返し

## 1. プラットフォーム抽象化レイヤーの作成

### 1.1 エディタ機能の抽象化
```typescript
// src/core/platform/editor.ts
export interface EditorPlatform {
  // タブ操作
  openTab(path: string): Promise<void>;
  closeTab(path: string): Promise<void>;
  getOpenTabs(): Promise<string[]>;
  
  // テキスト表示
  showTextDocument(content: string): Promise<void>;
  
  // 差分表示
  showDiff(original: string, modified: string): Promise<void>;
}

// VSCode実装
export class VSCodeEditor implements EditorPlatform {
  async openTab(path: string) {
    const doc = await vscode.workspace.openTextDocument(path);
    await vscode.window.showTextDocument(doc);
  }
  
  async closeTab(path: string) {
    // VSCode specific implementation
  }
  
  async getOpenTabs(): Promise<string[]> {
    return vscode.workspace.textDocuments.map(doc => doc.fileName);
  }
  
  // ... other implementations
}

// Headless実装
export class HeadlessEditor implements EditorPlatform {
  private openTabs: Set<string> = new Set();
  
  async openTab(path: string) {
    this.openTabs.add(path);
    console.log(`Opening tab: ${path}`);
  }
  
  async closeTab(path: string) {
    this.openTabs.delete(path);
    console.log(`Closing tab: ${path}`);
  }
  
  async getOpenTabs(): Promise<string[]> {
    return Array.from(this.openTabs);
  }
  
  // ... other implementations
}
```

### 1.2 ワークスペース機能の抽象化
```typescript
// src/core/platform/workspace.ts
export interface WorkspacePlatform {
  // ファイル操作
  readFile(path: string): Promise<string>;
  writeFile(path: string, content: string): Promise<void>;
  listFiles(path: string): Promise<string[]>;
  
  // 設定
  getConfiguration(section: string): any;
  
  // パス操作
  getWorkspaceFolder(): string;
  resolvePath(path: string): string;
}

// VSCode実装
export class VSCodeWorkspace implements WorkspacePlatform {
  // ... VSCode specific implementations
}

// Headless実装
export class HeadlessWorkspace implements WorkspacePlatform {
  // ... Headless specific implementations using node:fs
}
```

### 1.3 ターミナル機能の抽象化
```typescript
// src/core/platform/terminal.ts
export interface TerminalPlatform {
  createTerminal(name?: string): Terminal;
  executeCommand(command: string): Promise<string>;
  killProcess(): void;
}

interface Terminal {
  sendText(text: string): Promise<void>;
  show(): void;
  hide(): void;
}

// VSCode実装
export class VSCodeTerminal implements TerminalPlatform {
  // ... VSCode specific implementations
}

// Headless実装
export class HeadlessTerminal implements TerminalPlatform {
  // ... Headless specific implementations using node:child_process
}
```

### 1.4 通知機能の抽象化
```typescript
// src/core/platform/notification.ts
export interface NotificationPlatform {
  showInformation(message: string): Promise<void>;
  showWarning(message: string): Promise<void>;
  showError(message: string): Promise<void>;
}

// VSCode実装
export class VSCodeNotification implements NotificationPlatform {
  // ... VSCode specific implementations
}

// Headless実装
export class HeadlessNotification implements NotificationPlatform {
  // ... Headless specific implementations using console
}
```

## 2. プラットフォーム実装の切り替え

### 2.1 プラットフォームファクトリー
```typescript
// src/core/platform/index.ts
export class PlatformFactory {
  static createPlatform(isHeadless: boolean = false): Platform {
    if (isHeadless) {
      return {
        editor: new HeadlessEditor(),
        workspace: new HeadlessWorkspace(),
        terminal: new HeadlessTerminal(),
        notification: new HeadlessNotification(),
      };
    }
    
    return {
      editor: new VSCodeEditor(),
      workspace: new VSCodeWorkspace(),
      terminal: new VSCodeTerminal(),
      notification: new VSCodeNotification(),
    };
  }
}

export interface Platform {
  editor: EditorPlatform;
  workspace: WorkspacePlatform;
  terminal: TerminalPlatform;
  notification: NotificationPlatform;
}
```

### 2.2 使用例
```typescript
// src/core/Cline.ts
export class Cline {
  private platform: Platform;
  
  constructor(isHeadless: boolean = false) {
    this.platform = PlatformFactory.createPlatform(isHeadless);
  }
  
  async openFile(path: string) {
    try {
      const content = await this.platform.workspace.readFile(path);
      await this.platform.editor.showTextDocument(content);
    } catch (error) {
      await this.platform.notification.showError(`Failed to open file: ${error.message}`);
    }
  }
  
  // ... other methods
}
```

## 3. 実装手順

1. **プラットフォームインターフェース作成（2日）**
   - 各機能のインターフェース定義
   - VSCode実装の作成
   - Headless実装の作成

2. **既存コードの移行（2日）**
   - Cline.tsの依存関係を特定
   - プラットフォームインターフェースへの移行
   - エラーハンドリングの実装

3. **動作確認（1日）**
   - VSCode環境での動作確認
   - Headless環境での動作確認
   - エラーケースの確認

## 4. 制限事項

1. **実装しない機能**
   - 複雑なUI操作
   - デバッグ機能
   - 拡張機能連携

2. **簡略化する機能**
   - 差分表示 → テキスト出力
   - WebView → コンソール出力
   - ターミナル → 子プロセス実行

## 5. 動作確認方法

1. **Headlessモードでの実行**
```bash
HEADLESS=true node src/extension.js
```

2. **VSCodeでの実行**
```bash
# 通常通り実行
```

## 6. 制約

1. **コード変更の最小化**
   - 既存コードの変更はインターフェース利用への変更のみ
   - 新規ファイルは抽象化レイヤーとその実装のみ

2. **エラーハンドリング**
   - 各プラットフォーム実装で適切なエラーハンドリング
   - エラーメッセージの統一
   - ログ出力の整備

3. **テスト**
   - インターフェースのモック作成
   - 単体テストの実装
   - 統合テストの実装
``` 